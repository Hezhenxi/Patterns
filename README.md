# 设计模式-重构 & Spring源码阅读 :see_no_evil:

## 目录

<a name="3060-1621846615933"></a><a name="3qxd-1699830615556"></a>[源码阅读快捷键](#y7rk-1696756330756)

<a name="krk6-1699830615558"></a>[看方法实现的两种方法](#l9ks-1696756330757)

<a name="jdnw-1699830615560"></a>[普通方法：Ctr + 鼠标(B)  / Ctr +Alt +鼠标   ](#xiud-1645584792124)

<a name="smgf-1699830615562"></a>[抽象方法：Ctr +Alt +鼠标  ](#dqnd-1645584889594)

<a name="cuo7-1699830615564"></a>[查看方法用例](#iulz-1696756330758)

<a name="9sns-1699830615566"></a>[Ctr +鼠标  查看方法用例 useage](#nb1b-1645584977418)

<a name="jenr-1699830615568"></a>[类Structure ](#ybdy-1696756330759)

<a name="imxg-1699830615570"></a>[-ctrl+H结构图    ](#xygl-1699829959815)

<a name="x0yl-1699830615572"></a>[-ctrl+alt+U结构图表](#abj6-1699830019023)

<a name="pzvw-1699830615575"></a>[善用UML图 统一建模语言 （类图、方法调用时序图）](#xgvz-1699829941205)

<a name="aobq-1699830615577"></a>[=== 重构必备快捷键===](#u4qd-1699827590539)

<a name="oheb-1699830615579"></a>[Alt + Delete Safe Detele(安全删除，可用在方法上进行快速删除)](#7jgm-1699827592479)

<a name="narp-1699830615581"></a>[Shift +F6重命名-](#zbnc-1699827592481)

<a name="01pj-1699830615583"></a>[F5/F6复制/移动元素](#lcsh-1699827592483)

<a name="vqil-1699830615585"></a>[Ctrl + Alt +M抽取方法 Extract Method](#svos-1699827592485)

<a name="4cef-1699830615587"></a>[Ctrl + Alt+ C抽取常量](#i62k-1699827592487)

<a name="stqh-1699830615589"></a>[Ctrl +Alt+ F抽取字段](#3lvw-1699827592489)

<a name="n6oo-1699830615591"></a>[Ctrl + Alt+P抽取参数](#8vae-1699827592491)

<a name="c9t7-1699830615593"></a>[Ctrl + Alt+ V抽取变量](#0hnv-1699827592493)

<a name="ikx3-1699830615595"></a>[Ctrl + Alt+Shift +P抽取函数参数](#ljc1-1699827592495)

<a name="gb1f-1699830615597"></a>[Ctrl + Alt+Nlnline(转换为内联、方法链形式的调用，抽取方法的反操作)](#rltn-1699827592497)

<a name="ydo6-1699830615599"></a>[Ctrl + F6Change Signature(修改方法、类的签名，含参数、返回值类型等)](#8n32-1699827592499)

<a name="qwrb-1699830615601"></a>[设计模式-重构](#9rmz-1696756330760)

<a name="14te-1699830615603"></a>[通用原则](#w0cs-1696756330761)

<a name="oqsi-1699830615605"></a>[-代码 开放/封闭 原则，](#aj9d-1699828474925)

<a name="ttv0-1699830615607"></a>[- 多用组合，少用继承。](#6bga-1649502279787)

<a name="cyjd-1699830615609"></a>[-依赖倒置原则-面向接口编程](#ub5i-1649502231177)

<a name="j7qo-1699830615611"></a>[工厂模式：](#on9f-1649502485850)

<a name="cwae-1699830615613"></a>[单例模式：](#jm2n-1696756330762)

<a name="s4gt-1699830615615"></a>[装饰器模式：](#hzzm-1696756330763)

<a name="4wsz-1699830615617"></a>[代理模式：](#ph56-1696756330764)

<a name="hqtw-1699830615619"></a>[适配器模式：](#srgw-1696756330765)

<a name="9aza-1699830615621"></a>[策略模式:(常用替换if else）](#y76p-1696756330766)

<a name="lsau-1699830615623"></a>[AOP用到的设计模式](#xa1i-1699829834311)

<a name="izbu-1699830615625"></a>[-代理模式：](#2rlp-1699829827091)

<a name="qp80-1699830615627"></a>[-观察者模式：](#ujdc-1699829827427)

<a name="1xw1-1699830615629"></a>[《改善既有代码的设计》](#7xtw-1696756397430)



<a name="cgi3-1696756330752"></a><a name="y7rk-1696756330756"></a>**源码阅读快捷键**

<a name="l9ks-1696756330757"></a>**看方法实现的两种方法**

<a name="xiud-1645584792124"></a>**普通方法：Ctr + 鼠标(B)  / Ctr +Alt +鼠标**   

<a name="lchj-1699830145011"></a>查看方法声明，**PS:普通方法，可被继承重写，查看重写方法也用implement**  

<a name="dqnd-1645584889594"></a>**抽象方法：Ctr +Alt +鼠标**  

<a name="j1hg-1699830114755"></a>查看实现 implement  

<a name="iulz-1696756330758"></a>**查看方法用例**

<a name="nb1b-1645584977418"></a>**Ctr +鼠标  查看方法用例 useage**

<a name="ybdy-1696756330759"></a>**类Structure** 

<a name="st0g-1645585735206"></a>**>Object** 下的方法为重写方法  **PS： 源码中重写/覆盖父类方法会省略@override**

<a name="plpl-1645586157976"></a>**>Interface**   下的方法为为抽象方法   **PS: 不一定为接口，>Object 和 >Interface 可能是同一个类，不过分重写父类方法 和 实现抽象接口   如 BufferedWriter extends Writer**

<a name="xygl-1699829959815"></a>**-ctrl+H结构图**    

<a name="abj6-1699830019023"></a>**-ctrl+alt+U结构图表**

<a name="xgvz-1699829941205"></a>**善用UML图 统一建模语言 （类图、方法调用时序图）**

<a name="u4qd-1699827590539"></a>**=== 重构必备快捷键===**

<a name="7jgm-1699827592479"></a>**Alt + Delete Safe Detele(安全删除，可用在方法上进行快速删除)**

<a name="zbnc-1699827592481"></a>**Shift +F6重命名-**

<a name="lcsh-1699827592483"></a>**F5/F6复制/移动元素**

<a name="svos-1699827592485"></a>**Ctrl + Alt +M抽取方法 Extract Method**

<a name="i62k-1699827592487"></a>**Ctrl + Alt+ C抽取常量**

<a name="3lvw-1699827592489"></a>**Ctrl +Alt+ F抽取字段**

<a name="8vae-1699827592491"></a>**Ctrl + Alt+P抽取参数**

<a name="0hnv-1699827592493"></a>**Ctrl + Alt+ V抽取变量**

<a name="ljc1-1699827592495"></a>**Ctrl + Alt+Shift +P抽取函数参数**

<a name="rltn-1699827592497"></a>**Ctrl + Alt+Nlnline(转换为内联、方法链形式的调用，抽取方法的反操作)**

<a name="8n32-1699827592499"></a>**Ctrl + F6Change Signature(修改方法、类的签名，含参数、返回值类型等)**

<a name="9rmz-1696756330760"></a>**设计模式-重构**

<a name="w0cs-1696756330761"></a>**通用原则**

<a name="aj9d-1699828474925"></a>**-代码 开放/封闭 原则，**

<a name="6vzm-1678827441526"></a> **由Bertrand Meyer提出。**

<a name="jbzb-1641523387367"></a>其背后原理是，代码对于扩展应该是开放的，对于修改应该是封闭的。  4. 将重复代码封装，复用。

<a name="fpww-1641523479416"></a>好的设计，无需对代码太多的修改就可以添加新的特性。修改场景下，许多情况下只需要对极少数的方法稍加修改即可，

<a name="ojrr-1641523643289"></a>还有一些情况下只需要派生一个新的类即可。派生之后很重要的一点是要记得消除重复（看差异式编程，通过派生来添加新特性以及通过重构整合它们）

<a name="fhu0-1641523777550"></a>消除重复后，代码自然而然的往 开放/封闭 原则靠拢了。

<a name="6bga-1649502279787"></a>**- 多用组合，少用继承。**

<a name="ub5i-1649502231177"></a>**-依赖倒置原则-面向接口编程**

<a name="0r0t-1699828547828"></a>面向抽象接口编程，不要依赖具体实现，减少类与类的耦合性，提高系统的可读性和可维护性

<a name="on9f-1649502485850"></a>**工厂模式：**

<a name="p15i-1699828885173"></a>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂 方法使一个类的实例化延迟到其子类。

<a name="ibka-1699828954608"></a>面相接口编程，而不是具体的子类，java多态的体现。

<a name="jm2n-1696756330762"></a>**单例模式：**

<a name="qxnq-1678827433157"></a>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这 个实例。

<a name="frty-1699828922842"></a>分布式中还是单例模式吗？===类似分布式并发问题，通过分布式锁机制or数据库锁保证只生成一个实例，存储在分布式缓存中或数据库中

<a name="hzzm-1696756330763"></a>**装饰器模式：**

<a name="jf1v-1678827490022"></a>**静态代理加一层抽象类（duck）就是装饰器模式了(fly duck, roket duck)。**

<a name="oash-1678827451389"></a>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰 器模式相比生成子类更为灵活 。通常只有一个。

<a name="vkm1-1677978057446"></a>定义一个**抽象类实现接口**，组合接口(**持有接口对象，构造器注入**)，装饰器类**继承**抽象接口(**构造器引用super()**)，重写方法增强操作或增加新方法。

<a name="ooet-1677977953185"></a>装饰器模式适用于以下情况：

<a name="pdin-1677977953191"></a>当我们想要在不改变原有类结构的情况下，动态地给一个对象增加一些额外的功能或职责时，可以使用装饰器模式来实现[**3**](https://developer.aliyun.com/article/864585)

<a name="kmh9-1677978057815"></a>当我们想要通过组合不同的装饰类来得到多种功能组合时，可以使用装饰器模式来实现[**3**](https://developer.aliyun.com/article/864585)

<a name="ph56-1696756330764"></a>**代理模式：**

<a name="eqbx-1678827469637"></a>**（**被代理类/原始类实现接口），**代理类实现上相比装饰器类清楚一丢丢,少一层抽象类**

<a name="xrlu-1677978633053"></a>静态代理：代理类实现具体某个接口，组合接口(**持有接口对象，构造器注入**)，重写方法对被代理类进行增强。

<a name="rpgp-1677978642342"></a>动态代理：代理类实现反射类接口，通过反射动态生成代理类。对代理类进行增强。组合Object(持有Object对象，构造器注入)

<a name="acmn-1677977988299"></a>代理模式适用于以下情况：

<a name="7rfw-1677977953174"></a>当我们想要隐藏某个类时，可以为其提供代理类[**2**](https://www.cnblogs.com/V1haoge/p/6525527.html)

<a name="tpnk-1677977953178"></a>当一个类需要对不同的调用者提供不同的调用权限时，可以使用代理类来实现

<a name="kdh0-1677977953183"></a>当我们想要在真实主题执行之前或之后做一些预处理或后续处理时，可以使用代理类来实现

<a name="iqzu-1678033126970"></a>动态代理和静态代理都是设计模式中的代理模式，它们的主要目的是在不改变原始类的情况下，为其增加额外的功能。但是它们的实现方式有所不同，具体如下：

<a name="mrds-1678033153900"></a>实现方式：静态代理(也称编译时期代理)需要手动编写代理类，而动态代理不需要编写代理类，可以在运行时动态地生成代理类。

<a name="dh2g-1678033153904"></a>对象类型：静态代理和动态代理都需要代理类和原始类实现相同的接口，但**静态代理代理的是一个具体的类，而动态代理可以代理任何实现了接口的类。**

<a name="smcq-1678033153908"></a>生命周期：静态代理的代理对象在编译时就已经确定，不能动态改变，而动态代理的代理对象可以在运行时动态生成，可以根据需要动态改变。

<a name="t69s-1678033153912"></a>性能：静态代理在**编译时就已经生成了代理类(class文件）**，因此效率较高，但需要手动编写代理类(指定实例)；**动态代理在运行时动态生成代理类(利用反射机制生成的类也称动态类，**代理类的字节码是由虚拟机在运行时根据需要动态生成的，通常存储在内存中，而不是以 class 文件的形式存在磁盘上。**)，因此效率较低，但可以根据需要动态生成代理对象(反射)**。

<a name="abkp-1678033153914"></a><a name="6wve-1678033153916"></a>综上所述，静态代理和动态代理都可以实现代理模式的功能，但是它们的实现方式和应用场景有所不同。静态代理适用于代理类和原始类的关系比较固定的情况下，而动态代理适用于代理类和原始类的关系比较灵活的情况下。此外，动态代理还可以用于实现AOP（面向切面编程）等高级功能。

<a name="8vcc-1677978924874"></a>装饰器和代理的区别：

<a name="psj7-1677978919986"></a>装饰器模式关注于在一个对象上动态地添加方法，而代理模式关注于控制对对象的访问。

<a name="vdgu-1677978921450"></a>装饰器模式是为了增强原有对象的功能，而代理模式是为了施加控制或者提供额外的服务。

<a name="ecno-1677978921452"></a>装饰器模式中，装饰类和目标类是解耦的，装饰对象不感知目标对象的存在，由调用方控制对目标对象的引用。而代理模式中，代理类和目标类是耦合的，代理对象控制对目标对象的引用。

<a name="vany-1677978921454"></a>装饰器模式通常只有一个装饰类，而代理模式可以有多个代理类。

<a name="srgw-1696756330765"></a>**适配器模式：**

<a name="wmqp-1678827582248"></a>**新增一个适配接口保持与原接口方法相同**，干**代理模式**的活

<a name="ezxg-1678827562881"></a>适配器模式的核心思想是将一个类的接口转换成客户希望的另外一个接口。适配器模式可以解决接口不兼容的问题，让原本由于接口不匹配而无法在一起工作的类能够协同工作。

<a name="onis-1678028463506"></a>新表、老表

<a name="7zeq-1678028392835"></a>1.定义适配器接口，与原接口具有相同的方法名称和方法签名

<a name="uk3v-1678028421674"></a>2.实现适配器类，并引用原来的DAO接口和新DAO接口

<a name="y76p-1696756330766"></a>**策略模式:(常用替换if else）**

<a name="idgz-1678386529147"></a>策略接口

<a name="1imw-1678386551525"></a>策略实现类：多种测略

<a name="xyji-1678386594244"></a>环境类（contex）:持有策略接口引用， excute执行逻辑 

<a name="tiwh-1678386674027"></a>优点：提高代码可读性、符合开放封闭原则、实现算法和调用者之间的解耦，提高代码复用性

<a name="hxzr-1678386833573"></a>缺点：需要创建多个策略实现类和一个环境类、客户端需要知道所有策略对应关系（HashMap映射策略），增加了客户端复杂度

<a name="0elp-1696756397228"></a><a name="xa1i-1699829834311"></a>**AOP用到的设计模式**

<a name="2rlp-1699829827091"></a>**-代理模式：**

<a name="ku11-1699829827425"></a> Spring AOP基于代理模式实现了面向切面编程。它使用代理对象包装目标对象，在方法调用时可以在目标方法的前后织入横切关注点。

<a name="ujdc-1699829827427"></a>**-观察者模式：**

<a name="vtll-1699829827429"></a> Spring AOP中的通知（Advice）就类似于观察者模式中的观察者。它们可以观察切入点的状态并在需要时执行相应的操作。

<a name="7xtw-1696756397430"></a>**《改善既有代码的设计》**

<a name="5bsg-1696756435821"></a>1.重构的第一个案例
